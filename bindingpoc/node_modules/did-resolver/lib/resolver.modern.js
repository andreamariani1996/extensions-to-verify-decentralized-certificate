function r(){const r=new Map;return async(t,n)=>{if(t.params&&"true"===t.params["no-cache"])return await n();const e=r.get(t.did);if(void 0!==e)return e;const i=await n();return null!==i&&r.set(t.did,i),i}}function t(r,t){return t()}const n=new RegExp("^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.-]+(:[a-zA-Z0-9_.-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$");function e(r){if(""===r||!r)throw new Error("Missing DID");const t=r.match(n);if(t){const n={did:`did:${t[1]}:${t[2]}`,method:t[1],id:t[2],didUrl:r};if(t[4]){const r=t[4].slice(1).split(";");n.params={};for(const t of r){const r=t.split("=");n.params[r[0]]=r[1]}}return t[6]&&(n.path=t[6]),t[7]&&(n.query=t[7].slice(1)),t[8]&&(n.fragment=t[8].slice(1)),n}throw new Error(`Invalid DID ${r}`)}class i{constructor(n={},e){this.registry=n,this.cache=!0===e?r():e||t}async resolve(r){const t=e(r),n=this.registry[t.method];if(n){const r=await this.cache(t,()=>n(t.did,t,this));if(null==r)throw new Error(`resolver returned null for ${t.did}`);return r}throw new Error(`Unsupported DID method: '${t.method}'`)}}export{i as Resolver,r as inMemoryCache,t as noCache,e as parse};
//# sourceMappingURL=resolver.modern.js.map
